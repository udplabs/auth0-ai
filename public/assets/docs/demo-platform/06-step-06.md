***Still curious about implementing more "typical" RAG, huh? ðŸ¤¨***

Let's take a look at how Auth0 FGA can assist in retrieval augmented generation for use cases involving semantic search.

## Initialize FGA Retriever

Open `lib/ai/tools/search-transactions.ts`.

Inside you will find a heavily documented but only partially implemented tool. As implemented, results will *never* be returned -- exactly how security teams like it, right? Show them nothing! ðŸ¤£

1. You will need to complete the code for `STEP 3` and `STEP 5`.
2. You will then need to add the tool to the `tool-registry`. Open `lib/ai/tool-registry.ts` to complete `STEP 8` and `STEP 9` of this exercise.
3. Once you have completed all ***nine*** steps, go ahead and ask AIya a question like 'how much did I spend on rideshare this year?'.

> [!TIP]
> Not sure what to ask? Check out what transactions are available by navigating to **Accounts** âžž **Checking** and see what sort of transactions exist.
>
> Remember, `searchTransactions` is focused on *semantic* search. If you would like to have a better idea of how the document embeddings were created, check out `lib/ai/rag/create-documents.ts`

> [!NOTE]
> The `@auth0/ai` `FGAFilter` implementation is built on the concept of a 'retriever'.
> To learn more about retrievers check out [LangChain's conceptual guide](https://js.langchain.com/docs/concepts/retrievers/).

---
You may be wondering, '*Why is filtering **after** Vector search necessary? Why not before?*'

Glad you asked! Filtering after retrieval is needed because:
- **Embedding search ignores auth.** Instead it returns nearest vectors from the *whole index* (all accounts) **without** permission awareness.
- **Similarity scoring needs the full space.** Preâ€‘filtering by per-account ACLs would require per-user or per-account indexes (*explodes cost + complexity*).
- **Dynamic policies & conditions.** FGA decisions (i.e. limits, conditional relations) are evaluated *at request time*; An index rebuild for *every change* is **impractical**.
- **Multi-tenant leakage risk.** Without post-filtering, a user could infer existence or content of other tenantsâ€™ transactions (*privacy breach* ðŸ˜±).
- **Tool correctness.** Model context must only include authorized docs; filtering earlier in UI is insufficient (server is the trust boundary).
- **Maintainability.** Single shared index + uniform post-filtering is simpler than maintaining many segmented indexes.
- **Performance trade-off.** Cheaper to retrieve top-K then discard unauthorized than to precompute all allowed subsets continuously.
---