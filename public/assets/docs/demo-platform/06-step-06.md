***Curious about implementing more "typical" semantic search RAG? ü§®***

Let's take a look at how Auth0 FGA can assist in retrieval augmented generation for use cases involving *semantic search*.

But first, *why semantic search*?

As Elastic states:
> *Semantic search is a search engine technology that interprets the meaning of words and phrases. The results of a semantic search will return content matching the **meaning** of a query, as opposed to content that literally matches words in the query.*

Our use case will demonstrate the ability to use common language to query non-structured transactional data -- transaction descriptions, payees, memos, and merchant codes.

*We are aware there are ample tools & many different approaches to handle this type of use case.*

***The intent of this section is to introduce how an Auth0 FGA Retriever can be used to filter content *before* the model ingests it.***

> [!NOTE]
> Semantic search is a complete topic on its own and well beyond the scope of Auth0 & this lab.
>
> There are *numerous* resources available that can provide you with additional insights on the topic.
>
> Here are a few to start:
> - OpenAI: [Retrieval Augmented Generate (RAG) & Semantic Search for GPTs](https://help.openai.com/en/articles/8868588-retrieval-augmented-generation-rag-and-semantic-search-for-gpts)
> - LangChain: [Retrieval](https://python.langchain.com/docs/concepts/retrieval/)
> - Elastic: [What is semantic search?](https://www.elastic.co/what-is/semantic-search)

## Initialize FGA Retriever

Inside of `lib/ai/tools/search-transactions.ts` you will find a heavily documented, but only partially implemented, tool.

As currently implemented, results will *never* be returned -- exactly how security teams like it, right? Show them nothing! ü§£

I think we can do better than that for our users though. *Let's go!*

##### Open `lib/ai/tools/search-transactions.ts`.

##### STEP 1
- [x] ~~*User authorization*~~ _<span style='color: green; font-variant: small-caps'>‚Üê Done for you</span>_
- We shouldn't have to explain this one!

##### STEP 2
- [x] ~~*Lazy import FGAFilter*~~ _<span style='color: green; font-variant: small-caps'>‚Üê Done for you</span>_
- Lazy importing in an AI tool optimizes performance and correctness.
- **Key benefits:**
  - faster initial load/cold start;
  - smaller baseline memory consumption;
  - conditional execution;
  - isolation of potential code failures;
  - environment flexibility (i.e. Edge vs Node)
  - ... the list goes on. Ask Aiya if you want to learn more!

##### STEP 3
- [ ] *Instantiate the FGA filter*
- In order to perform batch permission checks against FGA, complete the code in the `buildQuery` with the proper user permissions.
- These are the same permission checks you previously implemented.

##### STEP 4
- [x] ~~*Initialize LocalVectorStore*~~ _<span style='color: green; font-variant: small-caps'>‚Üê Done for you</span>_

##### STEP 5
- [ ] *Apply authorization filter*
- Implement the fgaRetriever.filter() using the `rawResults`

##### STEP 6
- [x] ~~*Validate final response shape*~~ _<span style='color: green; font-variant: small-caps'>‚Üê Done for you</span>_
- This step runs the results through a Zod schema validation.
- *Not familiar with Zod?* Think of it like Typescript at runtime.

##### STEP 7
- [x] ~~*Return with ToolResponse wrapper*~~ _<span style='color: green; font-variant: small-caps'>‚Üê Done for you</span>_
- For this application we have opted for a common tool response for consistency (as you have likely noticed):
  ```ts
  {
    data: {{tool results}},
    status: 'success' | 'error' | ...,
    message: {{Message shown to user (if model decides to use it)}},
    dataCount: {{Helper to make it easier for the model to know there are results.}}
  }
  ```

##### STEP 8 & STEP 9
- [ ] Add the `searchTransactions` tool to the tool registry found in `lib/ai/tools/tool-registry.ts`
- The tool registry is used in `app/(chat)/api/chat/[id]/handlers/post.ts` to inform the model what tools are available.
- *If a tool is not added to the registry, the model will have knowledge of the tool's existence.*

  > [!TIP]
  > Review [Vercel's tool documentation](https://ai-sdk.dev/docs/foundations/tools) to learn more about how the Vercel AI SDK implements AI tools.

##### TRY IT
Once you have completed all ***nine*** steps, go ahead and ask Aiya a question like 'how much did I spend on rideshare this year?'.

> [!TIP]
> Not sure what to ask? Check out what transactions are available by navigating to **Accounts** ‚ûû **Checking** and see what sort of transactions exist.
>
> Remember, `searchTransactions` is focused on *semantic* search. If you would like to have a better idea of how the document embeddings were created, check out `lib/ai/rag/create-documents.ts`

> [!NOTE]
> The `@auth0/ai` `FGAFilter` implementation is built on the concept of a 'retriever'.
> To learn more about retrievers check out [LangChain's conceptual guide](https://js.langchain.com/docs/concepts/retrievers/).

---
You may be wondering, '*Why is filtering **after** Vector search necessary? Why not before?*'

Glad you asked! It depends heavily on your particular implementation but, in general, filtering after retrieval is needed because:
- **Embedding search ignores auth.** Instead it returns nearest vectors from the *whole index* (all accounts) **without** permission awareness.
- **Similarity scoring needs the full space.** Pre‚Äëfiltering by per-account ACLs would require per-user or per-account indexes (*explodes cost + complexity*).
- **Dynamic policies & conditions.** FGA decisions (i.e. limits, conditional relations) are evaluated *at request time*; An index rebuild for *every change* is **impractical**.
- **Multi-tenant leakage risk.** Without post-filtering, a user could infer existence or content of other tenants‚Äô transactions (*privacy breach* üò±).
- **Tool correctness.** Model context must only include authorized docs; filtering earlier in UI is insufficient (server is the trust boundary).
- **Maintainability.** Single shared index + uniform post-filtering is simpler than maintaining many segmented indexes.
- **Performance trade-off.** Cheaper to retrieve top-K then discard unauthorized than to precompute all allowed subsets continuously.
---

#### Congrats on completing Advanced FGA for RAG!