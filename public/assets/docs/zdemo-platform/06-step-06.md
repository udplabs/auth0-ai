***Curious about implementing more "typical" semantic search <abbr title='Retrieval-Augmented Generation'>RAG</abbr>? ü§®***

Let's take a look at how Auth0 <abbr title='Fine-Grained Authorization'>FGA</abbr> can assist in retrieval augmented generation for use cases involving *semantic search*.

But first, *why semantic search*?

As Elastic states:
> *Semantic search is a search engine technology that interprets the meaning of words and phrases. The results of a semantic search will return content matching the **meaning** of a query, as opposed to content that literally matches words in the query.*

Our use case will demonstrate the ability to use common language to query non-structured transactional data -- transaction descriptions, payees, memos, and merchant codes.

*We are aware there are ample tools & many different approaches to handle this type of use case.*

***The intent of this section is to introduce how an Auth0 <abbr title='Fine-Grained Authorization'>FGA</abbr> Retriever can be used to filter content *before* the model ingests it.***

<br>

> [!NOTE]
> Semantic search is a complete topic on its own and well beyond the scope of Auth0 & this lab.
>
> There are *numerous* resources available that can provide you with additional insights on the topic.
>
> Here are a few to start:
> - OpenAI: [Retrieval Augmented Generate (RAG) & Semantic Search for GPTs](https://help.openai.com/en/articles/8868588-retrieval-augmented-generation-rag-and-semantic-search-for-gpts)
> - LangChain: [Retrieval](https://python.langchain.com/docs/concepts/retrieval/)
> - Elastic: [What is semantic search?](https://www.elastic.co/what-is/semantic-search)

<br>

---

 ## ‚úÖ Expected Outcome for this step
- A LocalVectorStore populated with document embeddings.
- Ability to query Aiya about non-structured data (i.e. payees, memos, descriptions).
- Accounts with appropriate tuples.

*Let's get started!*

---

## Initialize <abbr title='Fine-Grained Authorization'>FGA</abbr> Retriever

Inside of `lib/ai/tools/search-transactions.ts` you will find a heavily documented, but only partially implemented, tool.

As currently implemented, results will *never* be returned -- exactly how security teams like it, right? Show them nothing! ü§£

I think we can do better than that for our users though. *Let's go!*

##### Open `lib/ai/tools/search-transactions.ts`.

##### STEP 1
- [x] ~~*Import FGAFilter and LocalVectorStore*~~ _<span style='color: green; font-variant: small-caps'>‚Üê Done for you</span>_

##### STEP 2
- [x] ~~*User authorization*~~ _<span style='color: green; font-variant: small-caps'>‚Üê Done for you</span>_
- We shouldn't have to explain this one!

##### STEP 3
- [ ] *Instantiate the <abbr title='Fine-Grained Authorization'>FGA</abbr> filter*
- In order to perform batch permission checks against <abbr title='Fine-Grained Authorization'>FGA</abbr>, complete the code in the `buildQuery` by checking for the proper user permissions.
- *These are the same permission checks you previously implemented.*

##### STEP 4
- [x] ~~*Initialize LocalVectorStore*~~ _<span style='color: green; font-variant: small-caps'>‚Üê Done for you</span>_

##### STEP 5
- [ ] *Apply authorization filter*
- Implement the `fgaRetriever.filter()` and filter the <kbd>rawResults</kbd>.

##### STEP 6
- [x] ~~*Validate final response shape*~~ _<span style='color: green; font-variant: small-caps'>‚Üê Done for you</span>_
- This step runs the results through a Zod schema validation.
- *Not familiar with Zod?* Think of it like Typescript at runtime.

##### STEP 7
- [x] ~~*Return with ToolResponse wrapper*~~ _<span style='color: green; font-variant: small-caps'>‚Üê Done for you</span>_
- For this application we have opted for a common tool response for consistency (as you have likely noticed):
  ```ts
  {
    data: {{tool results}},
    status: 'success' | 'error' | ...,
    message: {{Message shown to user (if model decides to use it)}},
    dataCount: {{Helper to make it easier for the model to know there are results.}}
  }
  ```

##### STEP 8
- [ ] Open `/lib/ai/tool-registry.ts`.
- [x] ~~*Import the tool*~~ _<span style='color: green; font-variant: small-caps'>‚Üê Done for you</span>_

##### STEP 9
- [ ] Add the `searchTransactions` tool to the tool registry found in `lib/ai/tool-registry.ts`
- The tool registry is used in <kbd>app/(chat)/api/chat/[id]/handlers/post.ts</kbd> to inform the model what tools are available.
- *If a tool is not added to the registry, the model will have knowledge of the tool's existence.*

  <br>

  > [!TIP]
  > Review [Vercel's tool documentation](https://ai-sdk.dev/docs/foundations/tools) to learn more about how the Vercel AI SDK implements AI tools.

  <br>

##### TRY IT
Once you have completed all ***nine*** steps, go ahead and ask Aiya a question like `how much did I spend on rideshare this year?`.

<br>

> [!TIP]
> Not sure what to ask? Check out what transactions are available by navigating to **Accounts** ‚ûû **Checking** and see what sort of transactions exist.
>
> Remember, <kbd>searchTransactions</kbd> is focused on *semantic* search. If you would like to have a better idea of how the document embeddings were created, check out <kbd>lib/ai/rag/create-documents.ts</kbd>

<br>

> [!NOTE]
> The <kbd>@auth0/ai</kbd> <kbd>FGAFilter</kbd> implementation is built on the concept of a 'retriever'.
>
> To learn more about retrievers check out [LangChain's conceptual guide](https://js.langchain.com/docs/concepts/retrievers/).

---
You may be wondering, <q>Why is filtering **after** Vector search necessary? Why not before?</q>

Glad you asked! It depends heavily on your particular implementation but, in general, filtering after retrieval is needed because:
- **Embedding search ignores auth.** Instead it returns nearest vectors from the *whole index* (all accounts) **without** permission awareness.
- **Similarity scoring needs the full space.** Pre‚Äëfiltering by per-account ACLs would require per-user or per-account indexes (*explodes cost + complexity*).
- **Dynamic policies & conditions.** <abbr title='Fine-Grained Authorization'>FGA</abbr> decisions (i.e. limits, conditional relations) are evaluated *at request time*; An index rebuild for *every change* is **impractical**.
- **Multi-tenant leakage risk.** Without post-filtering, a user could infer existence or content of other tenants‚Äô transactions (*privacy breach* üò±).
- **Tool correctness.** Model context must only include authorized docs; filtering earlier in UI is insufficient (server is the trust boundary).
- **Maintainability.** Single shared index + uniform post-filtering is simpler than maintaining many segmented indexes.
- **Performance trade-off.** Cheaper to retrieve top-K then discard unauthorized than to precompute all allowed subsets continuously.
---

#### Congrats on completing Advanced <abbr title='Fine-Grained Authorization'>FGA</abbr> for <abbr title='Retrieval-Augmented Generation'>RAG</abbr>!